/*
==========================================================
NAME:			BUTTON.H
AUTHOR:			RITHVIK NISHAD
ABOUT:			Button definition file
Last Updated:	October 6, 2018
==========================================================
*/

#include <graphics.h>
#include <string.h>

#include "P_TABLE\\LIB\\UI.H"
#include "P_TABLE\\LIB\\CDEF.H"
#include "P_TABLE\\LIB\\POINT2D.H"

#if !defined(__BUTTON_H)
#define __BUTTON_H


enum Bounds { LEFT = 0, TOP = 1, RIGHT = 2, BOTTOM = 3 };


void NotImplementedException() { }


class Button
{

	bool PreviousMouseHoverState;

	void Initialize()
	{
		Text = NULL;
		ClickEvent = NotImplementedException;
		Enabled = true;
		PreviousMouseHoverState = MouseHover();
	}

	public:

	char *Text;
	//char *Text_GC;

	Point2D A, B;

	byte BackColor;
	byte BackColor_Hovered;
	byte BorderColor;
	byte BorderColor_Hovered;
	byte ForeColor;
	byte ForeColor_Hovered;

	bool Enabled;

	void (*ClickEvent)();

	
	
	char* SetText(const char text[]);

	void SetBounds(Point2D &a, Point2D &b)
	{
		A.X = A.X;
		A.Y = A.Y;
		B.X = B.X;
		B.Y = B.Y;
	}

	void SetPositionAndSize(Size2D &size, Point2D &a)
	{
		A = a;
		B = Point2D(a.X + size.Width, a.Y + size.Height);
	}

	void SetPositionAndSize(Point2D &midpoint, Size2D &size) 
	{
		A = Point2D(midpoint.X - (size.Width / 2), midpoint.Y - (size.Height / 2));
		B = Point2D(midpoint.X + (size.Width / 2), midpoint.Y + (size.Height / 2));
	}



	bool MouseHover()
	{
		return ((Mouse::X < B.X) && (Mouse::X > A.X) && (Mouse::Y < B.Y) && (Mouse::Y > A.Y));
	}

	bool MouseClicked()
	{
		if (MouseHover() != PreviousMouseHoverState)
			Draw();

		if (Mouse::Button && MouseHover())
		{
			if (Enabled)
				ClickEvent();
			return true;
		}
		return false;
	}

	void Draw (bool AutoMouseHide = true, byte TextJustify = CENTER_TEXT)
	{
		if (AutoMouseHide)
			Mouse::Hide();

		FilledRectangle(A.X, A.Y, B.X, B.Y, (MouseHover() && Enabled) ? BackColor_Hovered : BackColor, (MouseHover() && Enabled) ? BorderColor_Hovered : BorderColor);

		settextjustify(TextJustify, CENTER_TEXT);
		settextstyle(0, HORIZ_DIR, 1);
		
		// setcolor((MouseHoverState && Enabled) ? BackColor_Hovered : BackColor);
		// outtextxy((B.X + A.X) / 2, (B.Y + A.Y) / 2, Text_GC);
		
		setcolor(MouseHoverState ? ForeColor_Hovered : ForeColor);
		outtextxy((B.X + A.X) / 2, (B.Y + A.Y) / 2, Text);
		
		if (AutoMouseHide)
			Mouse::Show();

		PreviousMouseHoverState = MouseHoverState;
	}

	Button()
	{
		Initialize();

		BackColor = LIGHTGRAY;
		BorderColor = DARKGRAY;

		BackColor_Hovered = DARKGRAY;
		BorderColor_Hovered = DARKGRAY;

		ForeColor = DARKGRAY;
		ForeColor_Hovered = WHITE;
	}

	Button(const char text[], byte backcolor, byte forecolor)
	{
		Initialize();
		
		SetText(text);
		
		BackColor = backcolor;
		BorderColor = BackColor;
		ForeColor = forecolor;

		BackColor_Hovered = BackColor;
		BorderColor_Hovered = BorderColor;
		ForeColor_Hovered = ForeColor;

	}

	~Button()
	{
		if (Text != NULL)
			delete[] Text;
			
		// if (Text_GC != NULL)
		// 	delete[] Text_GC;
	}

};

char* Button::SetText(const char text[]) 
{
	if (Text != NULL)
		delete[] Text;

	// if (Text_GC != NULL)
	// 	delete[] Text_GC;

	if (text != NULL)
	{
		Text = (char*)malloc(strlen(text) + 1);
		strcpy(Text, text);

		// Text_GC = (char*)malloc(strlen(text) + 1);

		// for (int i = 0; i < strlen(Text);)
		// 	*(Text_GC + i++) = char(219);
	
		// *(Text_GC + i + 1) = '\0';
	}

	return Text;
}


// class PropertyButton : public Button
// {

// 	byte currentBackColor() { return MouseHover() ? BackColor_Hovered : BackColor; }

// 	public:

// 	char *PropertyValue;

// 	byte ForeColor, ForeColor_Hovered, BackColor, BackColor_Hovered, BorderColor, BorderColor_Hovered, FontSize, FontStyle, FontHorizontalAlignment;

// 	enum BoundEnumerator { LEFT = 0, TOP, RIGHT, BOTTOM };
// 	int Bounds[4];

// 	void(*ClickEvent)(int args);

// 	void Draw()
// 	{
// 		FilledRectangle(A.X, A.Y, B.X, B.Y, MouseHover() ? BackColor_Hovered : BackColor, MouseHover() ? BorderColor_Hovered : BorderColor);
// 		settextjustify(FontHorizontalAlignment, FontHorizontalAlignment);
// 		settextstyle(FontStyle, HORIZ_DIR, FontSize);
// 		setcolor(MouseHover() ? ForeColor_Hovered : ForeColor);
// 		outtextxy((B.X + A.X) / 2, (B.Y + A.Y) / 2, PropertyValue);
// 	}

// 	char* SetValue(const char value[]) 
// 	{
// 		if (PropertyValue != NULL)
// 			delete PropertyValue;

// 		PropertyValue = (char*)malloc(strlen(value) + 1);
// 		strcpy(PropertyValue, value);

// 		return PropertyValue;
// 	}

// 	void SetPositionAndSize(Point2D midpoint, Size2D size) 
// 	{
// 		A.X = midpoint.X - (size.Width / 2);
// 		B.X = midpoint.X + (size.Width / 2);
// 		A.Y = midpoint.Y - (size.Height / 2);
// 		B.Y = midpoint.Y + (size.Height / 2);
// 	}

// 	void SetPositionAndSize(Size2D size, Point2D cornerTL)
// 	{
// 		A.X = cornerTL.X;
// 		B.X = cornerTL.X + size.Width;
// 		A.Y = cornerTL.Y;
// 		B.Y = cornerTL.Y + size.Height;
// 	}

// 	byte MouseHover() { return ((Mouse::X < B.X) && (Mouse::X > A.X) && (Mouse::Y < B.Y) && (Mouse::Y > A.Y)); }

// 	byte MouseClicked() 
// 	{ 
// 		static int prev_ms_state;

// 		prev_ms_state = MouseHover();
// 		if (Mouse::Button && MouseHover())
// 		{
// 			ClickEvent();
// 			return 1;
// 		}
// 		return 0;
// 	}

// 	PropertyButton()
// 	{

// 	}

// 	~PropertyButton()
// 	{
// 		delete[] PropertyValue;
// 	}

// };



#endif